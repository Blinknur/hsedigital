#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const COVERAGE_DIR = path.join(__dirname, '../coverage');
const TEST_RESULTS_DIR = path.join(__dirname, '../test-results');
const SUMMARY_FILE = path.join(TEST_RESULTS_DIR, 'summary.md');

function generateTestSummary() {
  const coverageSummaryPath = path.join(COVERAGE_DIR, 'coverage-summary.json');
  const junitPath = path.join(TEST_RESULTS_DIR, 'junit.xml');

  if (!fs.existsSync(coverageSummaryPath)) {
    console.error('âŒ Coverage summary not found');
    process.exit(1);
  }

  const coverageSummary = JSON.parse(fs.readFileSync(coverageSummaryPath, 'utf8'));
  const total = coverageSummary.total;

  let testStats = { total: 0, passed: 0, failed: 0, skipped: 0 };

  if (fs.existsSync(junitPath)) {
    const junitContent = fs.readFileSync(junitPath, 'utf8');
    const testsMatch = junitContent.match(/tests="(\d+)"/);
    const failuresMatch = junitContent.match(/failures="(\d+)"/);
    const skippedMatch = junitContent.match(/skipped="(\d+)"/);

    if (testsMatch) testStats.total = parseInt(testsMatch[1]);
    if (failuresMatch) testStats.failed = parseInt(failuresMatch[1]);
    if (skippedMatch) testStats.skipped = parseInt(skippedMatch[1]);
    testStats.passed = testStats.total - testStats.failed - testStats.skipped;
  }

  const summary = `# Test Summary Report

Generated: ${new Date().toISOString()}

## ğŸ“Š Test Results

| Status | Count |
|--------|-------|
| âœ… Passed | ${testStats.passed} |
| âŒ Failed | ${testStats.failed} |
| â­ï¸ Skipped | ${testStats.skipped} |
| **Total** | **${testStats.total}** |

## ğŸ“ˆ Code Coverage

| Metric | Coverage | Covered | Total |
|--------|----------|---------|-------|
| Lines | ${total.lines.pct}% | ${total.lines.covered} | ${total.lines.total} |
| Statements | ${total.statements.pct}% | ${total.statements.covered} | ${total.statements.total} |
| Functions | ${total.functions.pct}% | ${total.functions.covered} | ${total.functions.total} |
| Branches | ${total.branches.pct}% | ${total.branches.covered} | ${total.branches.total} |

## ğŸ¯ Coverage Status

${getCoverageStatus(total)}

## ğŸ“ Reports

- [HTML Coverage Report](../coverage/index.html)
- [Detailed Test Results](./index.html)
- [JUnit XML](./junit.xml)

---

*Generated by automated test suite*
`;

  fs.writeFileSync(SUMMARY_FILE, summary);
  console.log(`\nâœ… Test summary generated: ${SUMMARY_FILE}\n`);

  if (testStats.failed > 0) {
    console.error(`\nâš ï¸  ${testStats.failed} test(s) failed!\n`);
    process.exit(1);
  }
}

function getCoverageStatus(total) {
  const lines = total.lines.pct;
  const statements = total.statements.pct;
  const functions = total.functions.pct;
  const branches = total.branches.pct;

  const avgCoverage = (lines + statements + functions + branches) / 4;

  if (avgCoverage >= 80) {
    return 'ğŸŸ¢ **Excellent** - Coverage is above 80%';
  } else if (avgCoverage >= 60) {
    return 'ğŸŸ¡ **Good** - Coverage is between 60-80%';
  } else if (avgCoverage >= 40) {
    return 'ğŸŸ  **Fair** - Coverage is between 40-60%, consider adding more tests';
  } else {
    return 'ğŸ”´ **Poor** - Coverage is below 40%, additional tests needed';
  }
}

generateTestSummary();
